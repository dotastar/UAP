上来直接做题，Leetcode原题：
Text Justification

CSV Reader
/*
John,Smith,john.smith@gmail.com,Los Angeles,1
Jane,Roberts,janer@msn.com,"San Francisco, CA",0
"Alexandra ""Alex""",Menendez,alex.menendez@gmail.com,Miami,1
"""Alexandra Alex"""
John|Smith|john.smith@gmail.com|Los Angeles|1
Jane|Roberts|janer@msn.com|San Francisco, CA|0
Alexandra "Alex"|Menendez|alex.menendez@gmail.com|Miami|1
"Alexandra Alex"
*/
×Close

#include<iostream>
#include<vector>
#include<string>

using namespace std;

vector<string> decode_CSV(string csv) {
    vector<string> elems;
    bool inQuote = false;
    string buffer;
    for (int i=0; i<csv.length(); i++) {
        if (inQuote) {
            if (csv[i] == '"') {
                if (i == csv.length()-1) {
                    elems.push_back(buffer);
                    buffer = ""; 
                } else if (csv[i+1] == '"'){
                    buffer += csv[i+1];
                    i++;
                } else {
                    inQuote = false;
                }   
            } else
                buffer += csv[i];
        } else {
            if (csv[i] == '"') {
                inQuote = true;
            } else if (csv[i] == ',') {
                elems.push_back(buffer);
                buffer = ""; 
            } else
                buffer += csv[i];
        }   
    }   
    if (buffer.length()) elems.push_back(buffer);
    return elems;
}

string encode_CSV(vector<string> elems) {
    string res;
    for (auto s : elems) {
        res += s+"|";
    }   
    return res.substr(0, res.length()-1);
}

int main() {
    string csv1 = "John,Smith,john.smith@gmail.com,Los Angeles,1";
    string csv2 = "Jane,Roberts,janer@msn.com,\"San Francisco, CA\",0";
    string csv3 = "\"Alexandra \"\"Alex\"\"\",Menendez,alex.menendez@gmail.com,Miami,1";
    string csv4 = "\"\"\"Alexandra Alex\"\"\"";
    cout << encode_CSV(decode_CSV(csv1)) << endl;
    cout << encode_CSV(decode_CSV(csv2)) << endl;
    cout << encode_CSV(decode_CSV(csv3)) << endl;
    cout << encode_CSV(decode_CSV(csv4)) << endl;


    return 0;    
}

电面

不相邻的range 求和最大 [check-in date, check-out date/ check-in date, check-out date/ check-in date,….]求最多能租出去几天。


Onsite

Project Deep Diving

Behavior Cultural Fitting

Code: WordBreak 不许用brute force.

Code: Text Justification

Ping server: output the timestamp offset

首先是三个技术面：
1） Alien Dictionary (leetcode 上要钱题)
http://www.cnblogs.com/jcliBlogger/p/4758761.html
2） Text Justification
3） 写echo TCP client， 向面试官的server发请求， 读回数据。地里比较少人说这种， 我来详细说一下， 情境是这样的： 想象你开车， 踩下油门，车会加速，放开油门，车会减速。 client向server发的请求有以下2种： （a）STATUS –表示查询现在车的速度和踩下踏板的压力； （b）THROTTLE 50.1 — 这条指令是“THROTTLE” 加上一个数字， 表示我现在将踩油门的压力调为50.1

EXAMPLE: 比如在telnet中
STATUS
0.0 0.0 (这行是server返回的， 第一个数字表示压力，第二个数字表示速度)
THROTTLE 50.1 (这个指令发出 server没有返回)
STATUS
50.1 3.75 (可以看到速度在缓慢上升)
STATUS (过几秒后，你又发STATUS指令过去)
50.1 15.98 (速度依旧上升。。。)

对就是这样，像是简单物理实验。

写完TCP client后，要求是写一个方法将速度控制到达一个target speed

最后一个问题是求这个 delta力 和 delta速度 之间的函数关系。。。。。。。。醉了。我物理还给老师了。。。。。。时间不够了

希望可以帮助到大家！！！

补充内容 (2016-1-14 00:55):
补充一下core value面：
1）what bring you to airbnb?
2) what can you teach your co-workers after you get in?
3) describe a person whom you admire most
4) describe your experience with airbnb

补充内容 (2016-1-14 00:55):
5) where have you been to?
6) what will you do if you win a lottery such as Powerball?
7) what is the biggest fear in your life?
8) how do describe Airbnb to a people back to 2003?

补充内容 (2016-1-14 00:56):
9) if you have a book that writes about your whole life, will you read it? why?
10) if you have a time machine, and you can either go back or go forth, will you choose to go back or to go forth?

补充内容 (2016-1-14 00:56):
11) among all the features of airbnb, what do you want to improve?

补充内容 (2016-1-14 00:57):
就这么多了~想起来再加~大家觉得有用就给我加米哈

补充内容 (2016-1-14 12:59):
12) 描述一件你当时觉得非常risky的事情，你是怎么做的，结果如何









给一个2d array，要求写一个顺序访问这个2d array的Iterator，包括hasNext()与
next()。注意2d array的每行中元素的个数可能不一样，也可能为空。followup是写一
个remove()，注意是remove当前item，不是下一个item。
要求code能运行。也没有bug free，bug fix得比较快，还是给onsite了。跪求版上面
过airbnb的大牛们的面经，包括culture fit的问题，可站内，多谢了！

 Given a 2-D int array, write an iterator that traverses it   from left to right and top to bottom. The iterator has 2 methods - boolean hasNext() and int next(). The array can have rows of different sizes, so for e.g. 1, 2, 4, 5 5, 6 <null/empty>, 10, 40, 50 The 2D int array was represented as ArrayList<ArrayList<Integer>>().
 
 http://blog.dreasgrech.com/2010/03/javas-iterators-and-iterables.html
 
 package my.interview.samples;
 
 

import java.io.*;
import java.util.*;
import java.util.List;
import java.util.ArrayList;


/*
 * Implement an iterator for list of lists with the following methods:
 * hasNext
 * next
 * remove
 [[1,2],[3,4],[5,6]]
 [[1,2],[3,4],[],[],[5,6]]
 */


class ListIterator{

	// The data structure
	private List<List<Integer>> dList = new ArrayList<List<Integer>>();

	// Iterators for parent and child lists
	Iterator parentIterator;
	Iterator childIterator;

	public ListIterator(List<List<Integer>> dList) {

		this.dList = dList;
		this.parentIterator = dList.iterator();

	}


	public boolean hasNext(){
		// Check if child iterator is initialized
		if(childIterator != null) return childIterator.hasNext();

		if(parentIterator.hasNext()) {

			// Get the next child
			List l = (List)parentIterator.next();

			//			if(childIterator== null) 
			//childIterator = l.iterator();

			// If the parent has more children
			if(l != null)
				childIterator = l.iterator();
			else return false;

			return childIterator.hasNext();
		}

		return false;
	}

	public Object next() {
		// Check if child iterator is initialized
		if(childIterator != null && childIterator.hasNext()) return childIterator.next();

		if(parentIterator.hasNext()) {

			// Get the next child
			List l = (List) parentIterator.next();

			// If the parent has more children
			if(l != null)
				childIterator = l.iterator();
			else return null;

			return childIterator.next();
		}

		return null;

	}

	public void remove() throws Exception {
		// Check if child iterator is initialized
		if(childIterator != null) 
		{
			childIterator.remove(); return;
		}

		if(parentIterator.hasNext()) {
			
			// Get the next child
			List l = (List) parentIterator.next();

			// If the parent has more children
			if(l != null)
				childIterator = l.iterator();
			else return;

			childIterator.remove(); return;
		}	

	}

}

class AirBnB1 {
	public static void main(String[] args) {

		List<List<Integer>> dataList = new ArrayList<List<Integer>>();

		//[[1,2],[3,4],[5,6]]
		//[[1,2],[3,4],[],[],[5,6]]

		List<Integer> list1 = new ArrayList<Integer>();
		list1.add(1);
		list1.add(2);

		List<Integer> list2 = new ArrayList<Integer>();
		list1.add(3);
		list1.add(4);

		List<Integer> list3 = new ArrayList<Integer>();
		list1.add(5);
		list1.add(6);

		List<Integer> list4 = new ArrayList<Integer>();
		List<Integer> list5 = new ArrayList<Integer>();

		dataList.add(list1);
		dataList.add(list2);
		dataList.add(list4);
		dataList.add(list5);
		dataList.add(list3);


		ListIterator i = new ListIterator(dataList);

		System.out.println(i.next());
		System.out.println(i.next());

		try {
			i.remove();
		}catch(Exception e){
			e.printStackTrace();
		}

		System.out.println(i.next());

		System.out.println("New Iterator");
		ListIterator newI = new ListIterator(dataList);
		while(newI.hasNext()) {
			System.out.println(newI.next());
		}


	}
}

 
 
 
 Given An array of strings where "L" indicates land and "W" indicates water, and a coordinate marking a starting point in the middle of the ocean
The Challenge:
Find and mark the ocean in the map by changing appropriate W's to O's. An ocean coordinate is defined to be any coordinate directly adjacent to any other ocean coordinate.
https://github.com/naveen-tirupattur/Interviews/blob/master/Interviews/src/my/interview/samples/AirBnB.java

A：基本都是面经里出现过得题，感觉他家的题库比较小。coding只有两轮，但是如果
没跑出结果就肯定挂。另外他们家比较注重culture fit。最后有两轮扯淡的
1. 聊项目
2. 设计machine learning系统
3. Word ladder II
4. Alien dictionary
5&6. culture fit 扯淡







text justification
meeting room 找T1-T2内所有人空的时间段
alien dictionary
都要compile run
两轮culture各种无厘头~~~





palindrome pair (店面啊)
Airbnb: Palindromic pair of a list of strings
Given a list of strings, find all the palindromic pairs of the string and output the concatenated palindrome.

e.g. [abc, cba], output is abccba, cbaabc.
e.g. [aabc, cb], output is cbaabc



Understand the problem:
The brute-force solution to this problem is very simple. For each word, we search all the others and see if it can form a palindrome. Assume that the ave. length of each word is m and there are totally n words in the list, the time complexity would be O(n^2 * m). 

Solution:
1. Put all the reversed order of the input string into a Map. The key is the reversed order of the string, and the value is the indices of the word
2. For each word, get all its prefixes, If the prefix is in the map AND the rest of the string is a palindrome, then we can find a pair where the first half is the current word, and the second half is the reversed order of prefix.
3. For each word, get all its postfixes. If the postfix is in the map AND the first half of the string is palindrome, then we can find a pair where the reversed order of the postfix is the first part, and the word is the second part of the pair. 

The reason why we need to track the position of each word is to avoid the situation like ["c"], i.e. the word itself is a palindrome. Then we may mistakely concatenate a "cc" as a palindrome. So we can concatenate two words IFF
1. The key in the map is different from the current word
2. If they are the same, they must have different indices. 

Code (Java):

import java.io.*;
import java.util.*;
 
public class Solution{
  List<String> getPalindromaticPairs(String[] input) {
    Set<String> result = new HashSet<>();
    if (input == null || input.length == 0) {
      return new ArrayList<>();
    }
     
    // Step 1: put the reversed order of each word into the map
    Map<String, List<Integer>> map = new HashMap<>();
     
    for (int i = 0; i < input.length; i++) {
      String str = input[i];
      String reStr = reverse(str);
      if (!map.containsKey(reStr)) {
        List<Integer> indices = new ArrayList<>();
        indices.add(i);
        map.put(reStr, indices);
      } else {
        List<Integer> indices = map.get(reStr);
        indices.add(i);
      }
    }
     
    // Step 2: Iterate each word
    for (int i = 0; i < input.length; i++) {
      String str = input[i];
       
      // Get all the prefix of str, and append to the end
      for (int j = 1; j <= str.length(); j++) {
        String prefix = str.substring(0, j);
        String postfix = str.substring(j);
         
        if (map.containsKey(prefix) && isPalindrome(postfix)) {
          if (map.get(prefix).size() > 1 || !map.get(prefix).equals(str)) {
            String palin = str + reverse(prefix);
            result.add(palin);
          }
        }
      }
       
      // Get all postfix of the str, and insert to front
      for (int j = str.length() - 1; j >= 0; j--) {
        String postfix = str.substring(j);
        String prefix = str.substring(0, j);
         
        if (map.containsKey(postfix) && isPalindrome(prefix)) {
          if (map.get(postfix).size() > 1 || !map.get(postfix).equals(str)) {
            String palin = reverse(postfix) + str;
            result.add(palin);
          }
        }
      }
    }
     
    return new ArrayList<String>(result);
  }
   
  private String reverse(String s) {
    if (s == null || s.length() <= 1) {
      return s;
    }
     
    char[] array = s.toCharArray();
    int lo = 0;
    int hi = array.length - 1;
    while (lo < hi) {
      char temp = array[lo];
      array[lo] = array[hi];
      array[hi] = temp;
       
      lo++;
      hi--;
    }
     
    return new String(array);
  }
   
  private boolean isPalindrome(String s) {
    if (s == null || s.length() <= 1) {
      return true;
    }
     
    int lo = 0;
    int hi = s.length() - 1;
     
    while (lo < hi) {
      if (s.charAt(lo) != s.charAt(hi)) {
        return false;
      }
       
      lo++;
      hi--;
    }
     
    return true;
  }
   
  public static void main(String[] args) {
    Solution solution = new Solution();
    String[] input = new String[]{"abc", "cba", "c", "c"};
     
    List<String> result = solution.getPalindromaticPairs(input);
     
    for (String s : result) {
      System.out.println(s);
    }
  }
}


A (Airbnb)

1. 2D array, 访问顺序必须是‘回’字的方式，就是从外圈转到里圈，写出class,
Iterator, hasNext(), next().
2. 电话号码和计费的一个log, 去parse 看规定时间内哪个号码产生费用最高。
3. leetcode anagram 的一题变种
4. 有很多个sorted queue存在不同服务器上，如何有效的读取到一个 sorted 大queue
里 (google也面到了这题）
5. 设计db, 如何存取房东和房客的reviews, 如何maintain他们之间的关系。

Airbnb确实和大家说得一样面试官很nice, 内部装潢笔格明显很高，非常酷炫.
offer: 160k + 5000股／2年 ＝ 260k



好久以前的忘记发出来了。

电面： nested iterator, follow-up: remove function

onsite:

1. boggle game, 但是呢比如你现在走了一个词apple, 那么a, p, p, l, e这几个char的位置不能继续用了。于是给你一个board, 一个dict让你计算最多能有多少个valid单词出现在这个Board上面

2.
john’s travel city: a1 a2 c2 h8 j9
tom’s travel city: b1 a1 c3 z5
kate travel city: a2 a1 h8 x8

给你一个人john, 以及他的一堆朋友，让你计算出来和他travel的city相似度大于75%的所有朋友，并且根据这个相似度对朋友排序

3. 给一组meetings（每个meeting由start和end时间组成）。求出在所有输入meeting时间段内没有会议，也就是空闲的时间段。
每个subarray都已经sort好
举例：
[
[[1, 3], [6, 7]],
[[2, 4]],
[[2, 3], [9, 12]]
]
返回
[[4, 6], [7, 9]]

4. behavior: 要表现爱bnb

5. behavior: 要表现爱bnb

饭不是很好吃，最后被拒。

补充内容 (2015-12-9 15:25):
那个第一题，我现在还没明白怎么做才是对的。第二题应该是要倒排索引。


rd list 和一个target word，要求输出在word list 里跟target 
word的edit distance 相差不大于k的所有words。我写了一个基于edit distance的解
法(见下面)，程序是要从头到尾都要写，包括main函数和test数据。写完后他问有没有
更好的解法，我说可以用trie，但是我不觉得我能在剩余时间里写得出来基于trie的解
法，就大致说了一下我认为的思路。在此也求大牛给一个基于trie解法的code。
link: http://www.mitbbs.com/article_t/JobHunting/32692817.html


Airbnb是和Pinterest背靠背面的。当时由于Pinterest面得不好的缘故，压力非常大。
在这要大大赞一下我Airbnb的recruiter, 他是我见过最好的recruiter, 没有之一。每
一轮面试，包括电面完了以后，他都给我提供非常详细的反馈，比如说code写的不错，
面试官对我聊天的某个细节印象深刻等等。在面试的当天早上，当他得知我头天的
Pinterest没有面好，还专门花了半小时陪我逛Airbnb总部大楼，让我放松下来。面试
的安排上也尽量做到technical 和non-technical session 间隔开以便我有时间放松。
Airbnb面试需要强调一下的是coding不用白板。电面是在一个类似于leetcode 的网站
上直接写code (有一些关键词高亮，但没有函数auto completion 和报错提示), 而
onsite则是给你一台有eclipse的电脑，要求编译通过并能通过面试官提供的测试例子
。我电面碰到的是一个白人小哥，刚毕业没多久，code题算法很简单但是比较考一些
edge case的处理。过程中聊得很开心。反馈回来说小哥直接给了strong signal, 免第
二轮电面onsite。Onsite总共有7轮：两轮culture fit, 两轮 coding, 两轮system 
design, 一轮 project deep dive。 过程就不再累述了。Coding 题非leetcode 原题
但属于中等难度。System design 主要是结合Airbnb网站自己的feature 来问。中间有
一个插曲：我第一个coding 的面试官来晚了15分钟，后来又花了大概10分钟setup 电
脑，题目出得也比较偏，以至于我最后没能完成code。好在我面试之后及时把情况反映
给了recruiter, 他调查属实以后，加上我其他几轮的表现不错，给我争取到了加面两
轮的机会。加面过程比较顺利，第一轮是白哥哥manager 问culture fit 和 behavior 
question, 顺利过。第二轮直接上来考coding, 超水平发挥，写了大概80~90行程序一
次编译运行通过。得到两个strong signal后拿到offer。


1. regex match, slightly complicated version of http://leetcode.com/2011/09/regular-expression-matching.html
2. find maxium square inside a sqaure, similar to http://stackoverflow.com/questions/1726632/dynamic-programming-l
argest-square-block
3. edit distance



A家的题目跟Leetcode不是一个概念。
属于给你一个问题，你把model给出来，再写出代码，run，需要看到正确结果。
Coding interview考察点是：Can you illustrate the big picture of the problem?
Can you make something run?

Culture轮因人而异，有的人有3轮的。因为Airbnb是strong culture company，面试官
会从各个角度试探面试者的性格特征，包括旁敲侧击询问你跟朋友之间的愉快经历。最
好去看看A家CEO做的采访，对于“文化”的定义和意义。


最近面了airbnb，确实如前辈大牛所言，题目本身不难，但是要求固定时间内机器完成
，run出正确结果．第一次如此面，很不适应．第一个such case，差几分钟没出正确结
果．好在是个国人老兄，估计没有就此刁难．在此致谢一把．还有就是passion非常重
要，所是tech公司中，behavior interview分量最重的．由于签了nda，就不说原题了
．就summary一下：实际生活中code能力+好的behavior interview+system design 
skills．
现在被告知拿到了offer，但是package还不知道．如果知道了，会这里update一下．一
个很重要的问题，他家的business model到底如何？本来觉得市场比uber大，但是最近
试了both，觉得还是比不上：uber的user experience完全beat传统taxi，可见的将来
能够kill 传统taxi．而airbnb的user experience，很多时候比不上hotel．这个是指
combine price and quality．比如一个地方，hotel要２００，airbnb只是１２０，但
是加上cleaning fee，service fee，价钱差不多，而且cancellation policy比hotel
严格很多，干净程度以及location多半不如．不清楚这个business model能不能一直
work．感觉可见的将来，依然是hotel business的皮毛，远远不可能kill hotel 
business．


给一个2d array，要求写一个顺序访问这个2d array的Iterator，包括hasNext()与
next()。注意2d array的每行中元素的个数可能不一样，也可能为空。followup是写一
个remove()，注意是remove当前item，不是下一个item。
要求code能运行。也没有bug free，bug fix得比较快，还是给onsite了。跪求版上面
过airbnb的大牛们的面经，包括culture fit的问题，可站内，多谢了！


题目：难度一般，很多字典和字符串的题目，多leetcode变体，代码量相对大
要求：在电脑上写，能把给出的不算刁钻的test case跑对
安排：电面一轮，onsite 6轮（3轮coding + 1轮project deep dive + 2轮culture 
fit）
特点：1. 面试官把标准答案记得很清楚，需要在写之前把思路细节讲清楚并优化到最
优，能少用一点空间就少用一点，即使不能在数量级上产生影响。2. culture fit很独
特但也没有十分刁难，喜欢了解他们商业模式，爱学新东西，有common sense的人



Screen
网申一天后，小编收到HR电话，约定第一个电话面试时间。三天后，电面开始。面试官是一个美国人，很利索的自我介绍，然后马上进入Coding。题目是关于如何Parse csv file：举个例子，给定一个CSV文件，格式是 “some_name|some_address|some_phone|some_job”，要求输出Json format “{name:some_name, address:some_addres,phone:some_phone, job:some_job}”。输入内容中有些特殊符号要注意处理，这个面试官会提醒。小编的感觉，这道题目的重点是Bug free code，另外面试者需要在30分钟内完成代码，并且编译运行。最后面试官会用几个Test case来测试面试者的代码是否有问题。因此其实A家的电面难度并不低，应该用准备Onsite的标准对待。
Onsite
由于小编在和HR聊天的时候告知自己的选择窗口比较紧，所以电面当天下午收到Onsite通知。简短截说：A家的Onsite一共有七轮，前五轮每轮四十五分钟，后两轮是三十分钟的culture fit.
第一轮遇到一位亚裔姑娘。主要就是聊天，考察以前做过的项目。面试官会慢慢深入，展开问项目细节和个人贡献。具体的项目回答心得在上篇博客中有详细讨论。由于准备比较充分，所以这轮比较轻松。
第二轮是美国面试官，主要考察系统设计：设计一个distributed cache. 回答这类题目需要对分布式系统有一定了解，小编觉得以下几点是需要讲清楚的：
Distribute策略：当Cache数据量巨大的时候，需要用多个Node来存储Cache。由于Cache本质上是Key-value-pair，那么可以通过对Key进行类似Hash的Sharding可以决定Value需要存储/读取的Node.
Cache策略：基本上就是Pull (on-demand)/Push(regular update)的区别。具体情况要考虑需求的具体情况，比如对与Cache数据实时性的要求，对于Performance要求等，一定程度上也考察面试者的沟通能力。
Failure case以及Scalability的讨论，主要是展示面试者思考问题的全面性。
从第三轮开始，连续三轮Coding interviews: 每轮除去了面试官讨论的时间，大概只有三十分钟做Coding，加之每个解法都需要编译出结果，所以感觉时间比较紧迫。
基于数据结构的算法题：Encode an alien dictionary using a tree and then produce a dictionary using topological traversal. Topological sorting类型，Leetcode中等难度。
算法题：实现Regular expression match，比Leetcode的原题多一两个通配符，但思路想通，做过Leetcode那道题的朋友，写这题难度不大。
DP题，具体题目实在无法记得，印象中是中等难度的Leetcode的DP题，sorry.
这三轮技术面试，总体感觉时间比较紧。小编建议最好与面试无关的问题留到最后，因为有些技术问题会有Follow-up，最好留出足够时间做完所有关卡。
最后的两轮面试比较轻松。和两位Non-technical面试官聊天，很多Behavior questions，主要考察面试者是否适合公司文化。比如，为什么选择Airbnb？ 如何改进Airbnb现有的产品？你最想做的事？给你三分钟，教他一件事？这种类型的问题。最好面试前看看网上关于Airbnb文化相关的讨论，答题尽量贴合的它家的做事风格，一般来说，过关问题不大。
Onsite三点半面完所有七轮，五点左右接到Offer，整个面试体验还是非常不错的。
Reflection
小编感觉A家的面试主要有两个重点：Bug free code and culture fit. 三轮Coding越快写完越有利，很多面试官有Follow-up question，都做出来的话对拿Offer很有帮助。系统设计题，面试官问的非常详细，最好仔细看看类似题目的讨论（关注包子博客是必须的）。多插一句，有的面试官比较拽，态度不是很好，遇到这种情况，个人心态要处理好，不要着急，更不要get defensive，好好做题是关键！整体来看，A家办公条件非常Fancy，Work-life balance应该也不错，每个季度有500刀的Airbnb credit，鼓励员工使用Airbnb旅游。Offer package整体上中规中矩，如果认同A家的文化和愿景，这是一个很理想的可以改变世界的地方。


Airbnb的题目往往都很啰嗦，其实简单几句话就可以概括的。要求代码写完了能够编译，然后自己写测试用例并跑过。感觉这样的好处是的确很考察代码功力，那种当场一次bug free，然后跑几个测试用例全过的感觉很爽。不好的地方是容易增加变数，因为即使自己本身水平不变，不同时候发挥略有差异，检查一两个bug用的时间可能就没机会做后面的follow up了。
第一轮实现分页显示。给了以下一些输入数据，要求将以下行分页显示，每页12行，其中每行已经按score排好序，分页显示的时候如果有相同host id的行，则将后面同host id的行移到下一页。
[
"host_id,listing_id,score,city",
"1,28,300.1,SanFrancisco",
"4,5,209.1,SanFrancisco",
"20,7,208.1,SanFrancisco",
"23,8,207.1,SanFrancisco",
"16,10,206.1,Oakland",
"1,16,205.1,SanFrancisco",
"6,29,204.1,SanFrancisco",
"7,20,203.1,SanFrancisco",
"8,21,202.1,SanFrancisco",
"2,18,201.1,SanFrancisco",
"2,30,200.1,SanFrancisco",
"15,27,109.1,Oakland",
"10,13,108.1,Oakland",
"11,26,107.1,Oakland",
"12,9,106.1,Oakland",
"13,1,105.1,Oakland",
"22,17,104.1,Oakland",
"1,2,103.1,Oakland",
"28,24,102.1,Oakland",
"18,14,11.1,SanJose",
"6,25,10.1,Oakland",
"19,15,9.1,SanJose",
"3,19,8.1,SanJose",
"3,11,7.1,Oakland",
"27,12,6.1,Oakland",
"1,3,5.1,Oakland",
"25,4,4.1,SanJose",
"5,6,3.1,SanJose",
"29,22,2.1,SanJose",
"30,23,1.1,SanJose"
]
这题的思路不难，但是实现起来还是有点难度的。在遍历的时候需要维护一个LinkedHashMap作为page并且完成去重。用LinkedHashMap的好处是可以保证所有的entry是按插入的顺序排序的，所以仍然可以保证按score排序的性质。另外，一旦遇到相同的host_id，则将其对应的行存到另一个buffer里。由于需要变遍历边增减容器里的数据，需要用ListIterator，并调用remove和add方法。之前只用过remove，从来没用过add。
第二轮是他家一道高频题，给一堆租房的request，作为输入数组，找一个array subset，其中任意两个元素不能相邻，（因为要打扫房间），求使得子集里所有元素之和最大。一维DP解之，另外可以使用滚动数组让空间开销为常数。
第三轮是实现一个CSV格式的Parser。其中处理转义字符比较tricky，当时只给了三个最基本的test case，所以都过了，但是由于花了些时间debug，有些特殊情况一开始处理错了，后来没时间进行处理了。这一轮面得很郁闷，面试官没怎么理我，感觉在做自己的事情，没什么交流。测试的时候把不小心把输入内容给贴错了，花了不少时间检查。
他家的题目感觉除了第二轮实现起来简单，其它的题目都要写不少代码，45分钟码完bug free的确不简单。


Airbnb，
Phone Interview 09/23
给一个整数数组，求不相互挨着的数字可以想加得到的最大和
简单动归，半小时也差不多，不过不知道第二天直接受到拒信，发邮件求reconsider还被回复there is no feed back，楼主欲哭无泪，被dream company拒成这个样子也是醉了。。另外提一句，这一家的HR phone screen好像也比较重要，听说过几个同学跟HR聊了之后就没有下文的，所以各位同学还是注意一下。


题目：
给一个数组代表reservation request，suppose start date, end date back to back.
比如[5,1,1,5]代表如下预定：
Jul 1-Jul6
Jul6-Jul7
Jul7-Jul8
jul8-Jul13
当然最开始那个Jul 1是随便选就好的啦。
现在input的意义搞清楚了。还有一个限制，就是退房跟开始不能是同一天，比如如果接了Jul 1-Jul6，Jul6-Jul7就不能接了。那问题就是给你个数组，算算最多能把房子租出去多少天。这个例子的话就是10天。
[4,9,6]=10
[4,10,3,1,5]=15
思路是用DP，我解题的code：
private static int getMax(int[] requests){
int len=requests.length;
8 b0 C6 q8 t% Z5 y) S: B2 j* y
int first=0;
int second=0;
for(int i=0;i int temp=Math.max(requests+first,second);
first=second;
second=temp;
}
return second;
}
评论：move on到下一轮phone interview了。想必大家听说过Airbnb是在一个类似于LeetCode的网站写完直接运行test的，test还是在main函数里自己写，不是像LeetCode那样自动test。这个题我叙述的时候已经把很多没有用的废话去掉了，当时他讲给我的时候还有各种废话，把题意弄懂大概花了10min。然后刚开始我老想用greedy，浪费了一些时间。想到dp之后不知道怎么脑子打结又迷糊了半天，后来只剩15min才想清楚，6min写完code，4min写test并直接全对，剩五分钟瞎聊了一会儿。最惊险的一次电面。这思路回头再看是非常简单。


Airbnb: phone screen #1: 不相邻的range 求和最大 [check-in date, check-out date/ check-in date, check-out date/ check-in date,….]求最多能租出去几天。
phone screen #2: waived.
Airbnb: onsite #1. Project Deep Diving
onsite #2. Behavior Cultural Fitting
onsite #3. Code: WordBreak 不许用brute force.
onsite #4. Code: Text Justification
onsite #5. Ping server: output the timestamp offset
Dropbox: Given a pattern and a string input – find if string follows the same pattern and return 0 or 1. Examples: 1) Pattern : “abba”, input: “redblueredblue” should return 1. 2) Pattern: “aaaa”, input: “asdasdasdasd” should return 1. 3) Pattern: “aabb”, input: “xyzabcxzyabc” should return 0.
先给你有空格的版本：例如 pattern: “a a a a” input : “asd asd asd asd” 后给你没空格的版本：例如 Pattern: “aaaa”, input: “asdasdasdasd”


Airbnb，
Phone Interview 09/23
给一个整数数组，求不相互挨着的数字可以想加得到的最大和
简单动归，半小时也差不多，不过不知道第二天直接受到拒信，发邮件求reconsider还被回复there is no feed back，楼主欲哭无泪，被dream company拒成这个样子也是醉了。。另外提一句，这一家的HR phone screen好像也比较重要，听说过几个同学跟HR聊了之后就没有下文的，所以各位同学还是注意一下


Edit Distance


1. find all the combinations of a string in lowercase and uppercase. For example, string "ab" -> "ab", "Ab", "aB", "AB". So, you will have 2^n (n = number of chars in the string) output strings. The goal is for you to test each of these string and see if it match a hidden string.

2. Implement a simple regex parser which, given a string and a pattern, returns a booleanindicating whether the input matches the pattern. By simple, we mean that the regex can only contain special character: * (star), . (dot), + (plus). The star means what you'd expect, that there will be zero or more of previous character in that place in the pattern. The dot means any character for that position. The plus means one or more of previous character in that place in the pattern.


Store a set of sudden-death tournament results in a compact format (eg. a bit array) and a set of predicted match results (also in a bit array). Score the predictions, giving one point per correctly guessed match, without unpacking the bit array into a more convenient format (ie. you have to traverse the tree in-place).  


Find all words from a dictionary that are x edit distance away. 

Describe what happens when you enter a url in the web browser  

Sort a list of numbers in which each number is at a distance k from its actual position  


You have a plain with lots of rectangles on it, find out how many of them intersect  

two dimensional word permutation problem  


Given a dictionary, and a matrix of letters, find all the words in the matrix that are in the dictionary. (Going across, down or diagonally)  
