Airbnb电面是在一个类似于LeetCode的网站写完直接运行test的，test还是在main函数里自己写，不是像LeetCode那样自动test
https://hellosmallworld123.wordpress.com/2015/09/04/abnb-%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/
电面

1. CSV Reader/ Parse an escaped string into csv format. 举个例子，给定一个CSV文件，格式是 “some_name|some_address|some_phone|some_job”，要求输出Json format “{name:some_name, address:some_addres,phone:some_phone, job:some_job}”
2. Given a 2-D int array, write an iterator that traverses it   from left to right and top to bottom. The iterator has 2 methods - boolean hasNext() and int next(). The array can have rows of different sizes, so for e.g. 1, 2, 4, 5 5, 6 <null/empty>, 10, 40, 50 The 2D int array was represented as ArrayList<ArrayList<Integer>>().
3.  Given An array of strings where "L" indicates land and "W" indicates water, and a coordinate marking a starting point in the middle of the ocean
4. palindrome pair
5. 不相邻的range 求和最大 [check-in date, check-out date/ check-in date, check-out date/ check-in date,….]求最多能租出去几天。
6. 给一个整数数组，求不相互挨着的数字可以想加得到的最大和
7. 第一轮实现分页显示。给了以下一些输入数据，要求将以下行分页显示，每页12行，其中每行已经按score排好序，分页显示的时候如果有相同host id的行，则将后面同host id的行移到下一页。
8. 第二轮是他家一道高频题，给一堆租房的request，作为输入数组，找一个array subset，其中任意两个元素不能相邻，（因为要打扫房间），求使得子集里所有元素之和最大。一维DP解之，另外可以使用滚动数组让空间开销为常数。




上来直接做题，Leetcode原题：
Text Justification


Phone - 1 CSV Reader
/*
John,Smith,john.smith@gmail.com,Los Angeles,1
Jane,Roberts,janer@msn.com,"San Francisco, CA",0
"Alexandra ""Alex""",Menendez,alex.menendez@gmail.com,Miami,1
"""Alexandra Alex"""
John|Smith|john.smith@gmail.com|Los Angeles|1
Jane|Roberts|janer@msn.com|San Francisco, CA|0
Alexandra "Alex"|Menendez|alex.menendez@gmail.com|Miami|1
"Alexandra Alex"
*/
×Close

#include<iostream>
#include<vector>
#include<string>

using namespace std;

vector<string> decode_CSV(string csv) {
    vector<string> elems;
    bool inQuote = false;
    string buffer;
    for (int i=0; i<csv.length(); i++) {
        if (inQuote) {
            if (csv[i] == '"') {
                if (i == csv.length()-1) {
                    elems.push_back(buffer);
                    buffer = ""; 
                } else if (csv[i+1] == '"'){
                    buffer += csv[i+1];
                    i++;
                } else {
                    inQuote = false;
                }   
            } else
                buffer += csv[i];
        } else {
            if (csv[i] == '"') {
                inQuote = true;
            } else if (csv[i] == ',') {
                elems.push_back(buffer);
                buffer = ""; 
            } else
                buffer += csv[i];
        }   
    }   
    if (buffer.length()) elems.push_back(buffer);
    return elems;
}

string encode_CSV(vector<string> elems) {
    string res;
    for (auto s : elems) {
        res += s+"|";
    }   
    return res.substr(0, res.length()-1);
}

int main() {
    string csv1 = "John,Smith,john.smith@gmail.com,Los Angeles,1";
    string csv2 = "Jane,Roberts,janer@msn.com,\"San Francisco, CA\",0";
    string csv3 = "\"Alexandra \"\"Alex\"\"\",Menendez,alex.menendez@gmail.com,Miami,1";
    string csv4 = "\"\"\"Alexandra Alex\"\"\"";
    cout << encode_CSV(decode_CSV(csv1)) << endl;
    cout << encode_CSV(decode_CSV(csv2)) << endl;
    cout << encode_CSV(decode_CSV(csv3)) << endl;
    cout << encode_CSV(decode_CSV(csv4)) << endl;


    return 0;    
}




PHONE - 3
Given An array of strings where "L" indicates land and "W" indicates water, and a coordinate marking a starting point in the middle of the ocean
The Challenge:
Find and mark the ocean in the map by changing appropriate W's to O's. An ocean coordinate is defined to be any coordinate directly adjacent to any other ocean coordinate.
https://github.com/naveen-tirupattur/Interviews/blob/master/Interviews/src/my/interview/samples/AirBnB.java
 
 
Phone - 4. Palindromic pair of a list of strings
Given a list of strings, find all the palindromic pairs of the string and output the concatenated palindrome.

e.g. [abc, cba], output is abccba, cbaabc.
e.g. [aabc, cb], output is cbaabc

Understand the problem:
The brute-force solution to this problem is very simple. For each word, we search all the others and see if it can form a palindrome. Assume that the ave. length of each word is m and there are totally n words in the list, the time complexity would be O(n^2 * m). 

Solution:
1. Put all the reversed order of the input string into a Map. The key is the reversed order of the string, and the value is the indices of the word
2. For each word, get all its prefixes, If the prefix is in the map AND the rest of the string is a palindrome, then we can find a pair where the first half is the current word, and the second half is the reversed order of prefix.
3. For each word, get all its postfixes. If the postfix is in the map AND the first half of the string is palindrome, then we can find a pair where the reversed order of the postfix is the first part, and the word is the second part of the pair. 

The reason why we need to track the position of each word is to avoid the situation like ["c"], i.e. the word itself is a palindrome. Then we may mistakely concatenate a "cc" as a palindrome. So we can concatenate two words IFF
1. The key in the map is different from the current word
2. If they are the same, they must have different indices. 

Code (Java):

import java.io.*;
import java.util.*;
 
public class Solution{
  List<String> getPalindromaticPairs(String[] input) {
    Set<String> result = new HashSet<>();
    if (input == null || input.length == 0) {
      return new ArrayList<>();
    }
     
    // Step 1: put the reversed order of each word into the map
    Map<String, List<Integer>> map = new HashMap<>();
     
    for (int i = 0; i < input.length; i++) {
      String str = input[i];
      String reStr = reverse(str);
      if (!map.containsKey(reStr)) {
        List<Integer> indices = new ArrayList<>();
        indices.add(i);
        map.put(reStr, indices);
      } else {
        List<Integer> indices = map.get(reStr);
        indices.add(i);
      }
    }
     
    // Step 2: Iterate each word
    for (int i = 0; i < input.length; i++) {
      String str = input[i];
       
      // Get all the prefix of str, and append to the end
      for (int j = 1; j <= str.length(); j++) {
        String prefix = str.substring(0, j);
        String postfix = str.substring(j);
         
        if (map.containsKey(prefix) && isPalindrome(postfix)) {
          if (map.get(prefix).size() > 1 || !map.get(prefix).equals(str)) {
            String palin = str + reverse(prefix);
            result.add(palin);
          }
        }
      }
       
      // Get all postfix of the str, and insert to front
      for (int j = str.length() - 1; j >= 0; j--) {
        String postfix = str.substring(j);
        String prefix = str.substring(0, j);
         
        if (map.containsKey(postfix) && isPalindrome(prefix)) {
          if (map.get(postfix).size() > 1 || !map.get(postfix).equals(str)) {
            String palin = reverse(postfix) + str;
            result.add(palin);
          }
        }
      }
    }
     
    return new ArrayList<String>(result);
  }
   
  private String reverse(String s) {
    if (s == null || s.length() <= 1) {
      return s;
    }
     
    char[] array = s.toCharArray();
    int lo = 0;
    int hi = array.length - 1;
    while (lo < hi) {
      char temp = array[lo];
      array[lo] = array[hi];
      array[hi] = temp;
       
      lo++;
      hi--;
    }
     
    return new String(array);
  }
   
  private boolean isPalindrome(String s) {
    if (s == null || s.length() <= 1) {
      return true;
    }
     
    int lo = 0;
    int hi = s.length() - 1;
     
    while (lo < hi) {
      if (s.charAt(lo) != s.charAt(hi)) {
        return false;
      }
       
      lo++;
      hi--;
    }
     
    return true;
  }
   
  public static void main(String[] args) {
    Solution solution = new Solution();
    String[] input = new String[]{"abc", "cba", "c", "c"};
     
    List<String> result = solution.getPalindromaticPairs(input);
     
    for (String s : result) {
      System.out.println(s);
    }
  }
}


PHONE -5 
给一个数组代表reservation request，suppose start date, end date back to back.
比如[5,1,1,5]代表如下预定：
Jul 1-Jul6
Jul6-Jul7
Jul7-Jul8
jul8-Jul13
当然最开始那个Jul 1是随便选就好的啦。
现在input的意义搞清楚了。还有一个限制，就是退房跟开始不能是同一天，比如如果接了Jul 1-Jul6，Jul6-Jul7就不能接了。那问题就是给你个数组，算算最多能把房子租出去多少天。这个例子的话就是10天。
[4,9,6]=10
[4,10,3,1,5]=15
思路是用DP，我解题的code：
private static int getMax(int[] requests){
int len=requests.length;
8 b0 C6 q8 t% Z5 y) S: B2 j* y
int first=0;
int second=0;
for(int i=0;i int temp=Math.max(requests+first,second);
first=second;
second=temp;
}
return second;
}


PHONE- 7
第一轮实现分页显示。给了以下一些输入数据，要求将以下行分页显示，每页12行，其中每行已经按score排好序，分页显示的时候如果有相同host id的行，则将后面同host id的行移到下一页。

[

"host_id,listing_id,score,city",

"1,28,300.1,SanFrancisco",

"4,5,209.1,SanFrancisco",

"20,7,208.1,SanFrancisco",

"23,8,207.1,SanFrancisco",

"16,10,206.1,Oakland",

"1,16,205.1,SanFrancisco",

"6,29,204.1,SanFrancisco",

"7,20,203.1,SanFrancisco",

"8,21,202.1,SanFrancisco",

"2,18,201.1,SanFrancisco",

"2,30,200.1,SanFrancisco",

"15,27,109.1,Oakland",

"10,13,108.1,Oakland",

"11,26,107.1,Oakland",

"12,9,106.1,Oakland",

"13,1,105.1,Oakland",

"22,17,104.1,Oakland",

"1,2,103.1,Oakland",

"28,24,102.1,Oakland",

"18,14,11.1,SanJose",

"6,25,10.1,Oakland",

"19,15,9.1,SanJose",

"3,19,8.1,SanJose",

"3,11,7.1,Oakland",

"27,12,6.1,Oakland",

"1,3,5.1,Oakland",

"25,4,4.1,SanJose",

"5,6,3.1,SanJose",

"29,22,2.1,SanJose",

"30,23,1.1,SanJose"

]


这题的思路不难，但是实现起来还是有点难度的。在遍历的时候需要维护一个LinkedHashMap作为page并且完成去重。用LinkedHashMap的好处是可以保证所有的entry是按插入的顺序排序的，所以仍然可以保证按score排序的性质。另外，一旦遇到相同的host_id，则将其对应的行存到另一个buffer里。由于需要变遍历边增减容器里的数据，需要用ListIterator，并调用remove和add方法。之前只用过remove，从来没用过add。


===================================================================
===================================================================
===================================================================




Onsite

1. 
Project Deep Diving

Behavior Cultural Fitting

Code: WordBreak 不许用brute force.

Code: Text Justification

Ping server: output the timestamp offset

首先是三个技术面：
1） Alien Dictionary (leetcode 上要钱题)
http://www.cnblogs.com/jcliBlogger/p/4758761.html
2） Text Justification
3） 写echo TCP client， 向面试官的server发请求， 读回数据。地里比较少人说这种， 我来详细说一下， 情境是这样的： 想象你开车， 踩下油门，车会加速，放开油门，车会减速。 client向server发的请求有以下2种： （a）STATUS –表示查询现在车的速度和踩下踏板的压力； （b）THROTTLE 50.1 — 这条指令是“THROTTLE” 加上一个数字， 表示我现在将踩油门的压力调为50.1

EXAMPLE: 比如在telnet中
STATUS
0.0 0.0 (这行是server返回的， 第一个数字表示压力，第二个数字表示速度)
THROTTLE 50.1 (这个指令发出 server没有返回)
STATUS
50.1 3.75 (可以看到速度在缓慢上升)
STATUS (过几秒后，你又发STATUS指令过去)
50.1 15.98 (速度依旧上升。。。)

对就是这样，像是简单物理实验。

写完TCP client后，要求是写一个方法将速度控制到达一个target speed

最后一个问题是求这个 delta力 和 delta速度 之间的函数关系。。。。。。。。醉了。我物理还给老师了。。。。。。时间不够了

希望可以帮助到大家！！！

补充内容 (2016-1-14 00:55):
补充一下core value面：
1）what bring you to airbnb?
2) what can you teach your co-workers after you get in?
3) describe a person whom you admire most
4) describe your experience with airbnb

补充内容 (2016-1-14 00:55):
5) where have you been to?
6) what will you do if you win a lottery such as Powerball?
7) what is the biggest fear in your life?
8) how do describe Airbnb to a people back to 2003?

补充内容 (2016-1-14 00:56):
9) if you have a book that writes about your whole life, will you read it? why?
10) if you have a time machine, and you can either go back or go forth, will you choose to go back or to go forth?

补充内容 (2016-1-14 00:56):
11) among all the features of airbnb, what do you want to improve?

补充内容 (2016-1-14 00:57):
就这么多了~想起来再加~大家觉得有用就给我加米哈

补充内容 (2016-1-14 12:59):
12) 描述一件你当时觉得非常risky的事情，你是怎么做的，结果如何



2.
A：基本都是面经里出现过得题，感觉他家的题库比较小。coding只有两轮，但是如果
没跑出结果就肯定挂。另外他们家比较注重culture fit。最后有两轮扯淡的
1). 聊项目
2). 设计machine learning系统
3). Word ladder II
4). Alien dictionary
5&6). culture fit 扯淡


3. 
text justification
meeting room 找T1-T2内所有人空的时间段
alien dictionary
都要compile run
两轮culture各种无厘头~~~



4.
1). 2D array, 访问顺序必须是‘回’字的方式，就是从外圈转到里圈，写出class,
Iterator, hasNext(), next().
2). 电话号码和计费的一个log, 去parse 看规定时间内哪个号码产生费用最高。
3). leetcode anagram 的一题变种
4). 有很多个sorted queue存在不同服务器上，如何有效的读取到一个 sorted 大queue
里 (google也面到了这题）
5). 设计db, 如何存取房东和房客的reviews, 如何maintain他们之间的关系。

Airbnb确实和大家说得一样面试官很nice, 内部装潢笔格明显很高，非常酷炫.
offer: 160k + 5000股／2年 ＝ 260k


5.

1). boggle game, 但是呢比如你现在走了一个词apple, 那么a, p, p, l, e这几个char的位置不能继续用了。于是给你一个board, 一个dict让你计算最多能有多少个valid单词出现在这个Board上面

2).
john’s travel city: a1 a2 c2 h8 j9
tom’s travel city: b1 a1 c3 z5
kate travel city: a2 a1 h8 x8

给你一个人john, 以及他的一堆朋友，让你计算出来和他travel的city相似度大于75%的所有朋友，并且根据这个相似度对朋友排序

3). 给一组meetings（每个meeting由start和end时间组成）。求出在所有输入meeting时间段内没有会议，也就是空闲的时间段。
每个subarray都已经sort好
举例：
[
[[1, 3], [6, 7]],
[[2, 4]],
[[2, 3], [9, 12]]
]
返回
[[4, 6], [7, 9]]

4). behavior: 要表现爱bnb

5). behavior: 要表现爱bnb

饭不是很好吃，最后被拒。

补充内容 (2015-12-9 15:25):
那个第一题，我现在还没明白怎么做才是对的。第二题应该是要倒排索引。

rd list 和一个target word，要求输出在word list 里跟target 
word的edit distance 相差不大于k的所有words。我写了一个基于edit distance的解
法(见下面)，程序是要从头到尾都要写，包括main函数和test数据。写完后他问有没有
更好的解法，我说可以用trie，但是我不觉得我能在剩余时间里写得出来基于trie的解
法，就大致说了一下我认为的思路。在此也求大牛给一个基于trie解法的code。
link: http://www.mitbbs.com/article_t/JobHunting/32692817.html


6. 

1). regex match, slightly complicated version of http://leetcode.com/2011/09/regular-expression-matching.html
2). find maxium square inside a sqaure, similar to http://stackoverflow.com/questions/1726632/dynamic-programming-l
argest-square-block
3). edit distance


7. 
由于小编在和HR聊天的时候告知自己的选择窗口比较紧，所以电面当天下午收到Onsite通知。简短截说：A家的Onsite一共有七轮，前五轮每轮四十五分钟，后两轮是三十分钟的culture fit.
第一轮遇到一位亚裔姑娘。主要就是聊天，考察以前做过的项目。面试官会慢慢深入，展开问项目细节和个人贡献。具体的项目回答心得在上篇博客中有详细讨论。由于准备比较充分，所以这轮比较轻松。
第二轮是美国面试官，主要考察系统设计：设计一个distributed cache. 回答这类题目需要对分布式系统有一定了解，小编觉得以下几点是需要讲清楚的：
Distribute策略：当Cache数据量巨大的时候，需要用多个Node来存储Cache。由于Cache本质上是Key-value-pair，那么可以通过对Key进行类似Hash的Sharding可以决定Value需要存储/读取的Node.
Cache策略：基本上就是Pull (on-demand)/Push(regular update)的区别。具体情况要考虑需求的具体情况，比如对与Cache数据实时性的要求，对于Performance要求等，一定程度上也考察面试者的沟通能力。
Failure case以及Scalability的讨论，主要是展示面试者思考问题的全面性。
从第三轮开始，连续三轮Coding interviews: 每轮除去了面试官讨论的时间，大概只有三十分钟做Coding，加之每个解法都需要编译出结果，所以感觉时间比较紧迫。
基于数据结构的算法题：Encode an alien dictionary using a tree and then produce a dictionary using topological traversal. Topological sorting类型，Leetcode中等难度。
算法题：实现Regular expression match，比Leetcode的原题多一两个通配符，但思路想通，做过Leetcode那道题的朋友，写这题难度不大。
DP题，具体题目实在无法记得，印象中是中等难度的Leetcode的DP题，sorry.
这三轮技术面试，总体感觉时间比较紧。小编建议最好与面试无关的问题留到最后，因为有些技术问题会有Follow-up，最好留出足够时间做完所有关卡。
最后的两轮面试比较轻松。和两位Non-technical面试官聊天，很多Behavior questions，主要考察面试者是否适合公司文化。比如，为什么选择Airbnb？ 如何改进Airbnb现有的产品？你最想做的事？给你三分钟，教他一件事？这种类型的问题。最好面试前看看网上关于Airbnb文化相关的讨论，答题尽量贴合的它家的做事风格，一般来说，过关问题不大。
Onsite三点半面完所有七轮，五点左右接到Offer，整个面试体验还是非常不错的。
Reflection
小编感觉A家的面试主要有两个重点：Bug free code and culture fit. 三轮Coding越快写完越有利，很多面试官有Follow-up question，都做出来的话对拿Offer很有帮助。系统设计题，面试官问的非常详细，最好仔细看看类似题目的讨论（关注包子博客是必须的）。多插一句，有的面试官比较拽，态度不是很好，遇到这种情况，个人心态要处理好，不要着急，更不要get defensive，好好做题是关键！整体来看，A家办公条件非常Fancy，Work-life balance应该也不错，每个季度有500刀的Airbnb credit，鼓励员工使用Airbnb旅游。Offer package整体上中规中矩，如果认同A家的文化和愿景，这是一个很理想的可以改变世界的地方。


8.
Airbnb的题目往往都很啰嗦，其实简单几句话就可以概括的。要求代码写完了能够编译，然后自己写测试用例并跑过。感觉这样的好处是的确很考察代码功力，那种当场一次bug free，然后跑几个测试用例全过的感觉很爽。不好的地方是容易增加变数，因为即使自己本身水平不变，不同时候发挥略有差异，检查一两个bug用的时间可能就没机会做后面的follow up了。
第一轮实现分页显示。给了以下一些输入数据，要求将以下行分页显示，每页12行，其中每行已经按score排好序，分页显示的时候如果有相同host id的行，则将后面同host id的行移到下一页。
[
"host_id,listing_id,score,city",
"1,28,300.1,SanFrancisco",
"4,5,209.1,SanFrancisco",
"20,7,208.1,SanFrancisco",
"23,8,207.1,SanFrancisco",
"16,10,206.1,Oakland",
"1,16,205.1,SanFrancisco",
"6,29,204.1,SanFrancisco",
"7,20,203.1,SanFrancisco",
"8,21,202.1,SanFrancisco",
"2,18,201.1,SanFrancisco",
"2,30,200.1,SanFrancisco",
"15,27,109.1,Oakland",
"10,13,108.1,Oakland",
"11,26,107.1,Oakland",
"12,9,106.1,Oakland",
"13,1,105.1,Oakland",
"22,17,104.1,Oakland",
"1,2,103.1,Oakland",
"28,24,102.1,Oakland",
"18,14,11.1,SanJose",
"6,25,10.1,Oakland",
"19,15,9.1,SanJose",
"3,19,8.1,SanJose",
"3,11,7.1,Oakland",
"27,12,6.1,Oakland",
"1,3,5.1,Oakland",
"25,4,4.1,SanJose",
"5,6,3.1,SanJose",
"29,22,2.1,SanJose",
"30,23,1.1,SanJose"
]
这题的思路不难，但是实现起来还是有点难度的。在遍历的时候需要维护一个LinkedHashMap作为page并且完成去重。用LinkedHashMap的好处是可以保证所有的entry是按插入的顺序排序的，所以仍然可以保证按score排序的性质。另外，一旦遇到相同的host_id，则将其对应的行存到另一个buffer里。由于需要变遍历边增减容器里的数据，需要用ListIterator，并调用remove和add方法。之前只用过remove，从来没用过add。
第二轮是他家一道高频题，给一堆租房的request，作为输入数组，找一个array subset，其中任意两个元素不能相邻，（因为要打扫房间），求使得子集里所有元素之和最大。一维DP解之，另外可以使用滚动数组让空间开销为常数。
第三轮是实现一个CSV格式的Parser。其中处理转义字符比较tricky，当时只给了三个最基本的test case，所以都过了，但是由于花了些时间debug，有些特殊情况一开始处理错了，后来没时间进行处理了。这一轮面得很郁闷，面试官没怎么理我，感觉在做自己的事情，没什么交流。测试的时候把不小心把输入内容给贴错了，花了不少时间检查。
他家的题目感觉除了第二轮实现起来简单，其它的题目都要写不少代码，45分钟码完bug free的确不简单。


9.
Airbnb: onsite #1. Project Deep Diving
onsite #2. Behavior Cultural Fitting
onsite #3. Code: WordBreak 不许用brute force.
onsite #4. Code: Text Justification
onsite #5. Ping server: output the timestamp offset
Dropbox: Given a pattern and a string input – find if string follows the same pattern and return 0 or 1. Examples: 1) Pattern : “abba”, input: “redblueredblue” should return 1. 2) Pattern: “aaaa”, input: “asdasdasdasd” should return 1. 3) Pattern: “aabb”, input: “xyzabcxzyabc” should return 0.
先给你有空格的版本：例如 pattern: “a a a a” input : “asd asd asd asd” 后给你没空格的版本：例如 Pattern: “aaaa”, input: “asdasdasdasd”


Edit Distance


1. find all the combinations of a string in lowercase and uppercase. For example, string "ab" -> "ab", "Ab", "aB", "AB". So, you will have 2^n (n = number of chars in the string) output strings. The goal is for you to test each of these string and see if it match a hidden string.

2. Implement a simple regex parser which, given a string and a pattern, returns a booleanindicating whether the input matches the pattern. By simple, we mean that the regex can only contain special character: * (star), . (dot), + (plus). The star means what you'd expect, that there will be zero or more of previous character in that place in the pattern. The dot means any character for that position. The plus means one or more of previous character in that place in the pattern.


Store a set of sudden-death tournament results in a compact format (eg. a bit array) and a set of predicted match results (also in a bit array). Score the predictions, giving one point per correctly guessed match, without unpacking the bit array into a more convenient format (ie. you have to traverse the tree in-place).  


Find all words from a dictionary that are x edit distance away. 

Describe what happens when you enter a url in the web browser  

Sort a list of numbers in which each number is at a distance k from its actual position  


You have a plain with lots of rectangles on it, find out how many of them intersect  

two dimensional word permutation problem  


Given a dictionary, and a matrix of letters, find all the words in the matrix that are in the dictionary. (Going across, down or diagonally)  
